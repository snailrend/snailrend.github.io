# mysql 学习笔记

## mysql的内部结构

![img](0d2070e8f84c4801adbfa03bda1f98d9.png)

大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

### 连接器

连接器负责跟客户端建立连接、获取权限、维持和管理连接。一个用户成功建立连接后,即使账号被修改了权限,也不会影响已经存在的连接权限。

可以通过`show processlist `命令看到mysql当前的所有连接，其中会显示连接的状态。默认参数下，客户端8个小时没有请求，将会断开此连接。

建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。但是**全部使用长连接**后，你可能会发现，有些时候 MySQL 占用**内存涨得特别快**，这是因为 MySQL 在执行过程中**临时使用的内存是管理在连接对象里面**的。这些资源会在**连接断开的时候才释放**。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。

**怎么解决这个问题呢？可以考虑以下两种方案。**

1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
2. 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

### 查询缓存

MySQL 拿到一个查询请求后，会**先到查询缓存看看**，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。**key 是查询的语句，value 是查询的结果**。如果你的查询能够直接在这个**缓存中找到 key**，那么这个 value 就会被直接**返回**给客户端。

如果语句**不在查询缓存**中，就会**继续后面的执行阶段**。执行完成后，执行结果会被存入查询缓存中。

但是大多数情况下我会**建议你不要使用查询缓存**，为什么呢？因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个**表的更新**，这个表上**所有的查询缓存都会被清空**。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

**MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。**

### 分析器

分析器会对Sql语句进行`词法分析`，识别出语句中的字符串都代表什么，还会进行`语法分析`判断Sql是否满足MySql的语法。

### 优化器

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

### 执行器

开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。

如果查询语句没有使用索引，那么执行器的执行流程是这样的：

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

**也就是说，如果查询语句没有索引，就会进行全表扫描。**

富国查询语句使用的索引，逻辑也是类似，只是每次都调用的时“获取满足条件的第一行”这个接口

## mysql的日志系统

mysql更新数据是先写日志，再写磁盘，myslq有两种日志：

1. redo log（重做日志）

   `redo log`会记录每一条会更改数据库的操作。当`redo log`中记录的数据超过配置的大小时，就将数据记录更新到数据文件，然后将已经更新到数据文件的日志清除，腾出空间。`redo log`是`InnoDB`引擎特有的日志。

   简单的说，`redo log`是记录某个数据页做了什么改动。例如某个字段的值从0变成1。

2. binlog（归档日志）

   `binlog`会记录数据库中当下数据的现状，相当于快照。`binlog`有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。

更新数据时日志记录操作步骤如下：

1. 更新数据到内存
2. 将更新操作日志写入到`redo log`，此时这条log是 `prepare`状态
3. 将操作写入到`binlog`中
4. 将之前写入`redo log`的日志改为`commit`状态

## mysql 的事务

### 事务的隔离级别

MySQL的标准事务隔离级别有：

- 读未提交（read uncommitted）

  当一个事务没有提交的时候，在事务内的更改也可以被别的事务看到

- 读提交（read committed）

  一个事务提交后，它做的更改才能被别的事务看到。

- 可重复读（repeatable read）

  一个事务中看到的数据总是跟这个事务在事务启动时看到的一致。

- 串行化（serializable ）

  对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

### 事务隔离的实现

在 MySQL 中，实际上**每条记录在更新的时候都会同时记录一条回滚操作**。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

事务中每次查询一条数据的时候，都会创建一个`read view`，如果是`可重复读`的事务隔离，此事务中每次查询相同的数据都会使用同一个`read view`，这样就实现了事务中每次查询都会得到同样结果的效果，而创建的`read view`就是根据某个回滚日志而创建，当一个回滚日志没有再被引用的时候，就会被删除。也就是说，回滚日志会在系统确定这条数据**不会再需要被回滚到此状态**的时候**被删除**。

而一个`read view`会保持再一个事务中，如果使用很长的事务就会导致回滚日志得不到清理，导致日志变得很大，长事务还会占用锁资源，导致整个库的性能急速下降。



### 事务的启动方式

1. 显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。
2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。
3. 使用 commit work and chain 语法可以再提交一个事务的同时开启一个新的事务。

## mysql 索引

### 索引实现方式

1. 哈希表

   哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。

   若是有多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。同样的哈希值就放在同个链表。

   **哈希表这种结构适用于只有等值查询的场景**

2. 有序数组

   有序数组是按照某个属性进行排序后放入数组中，**有序数组在等值查询和范围查询场景中的性能就都非常优秀**，但是有序数组的**插入效率太低**，每次插入都要移动后面的数据。

3. 搜索树

   搜索树是一个统称，包括二叉搜索树、N叉搜索树等。

   - 二叉搜索树

     二叉搜索树的特点是：**每个节点的左儿子小于父节点，父节点又小于右儿子。**查询的时间复杂度就是O(log(N))，为了维持这样的查询复杂度，需要在插入的时候保持这棵树是平衡二叉树，所以插入的时间复杂度也是O(log(N))。

   - N叉搜索树

     虽然二叉树的搜索效率最高，但是由于数据库的数据不仅保持在内存中，还保持在磁盘上，而磁盘的随机读写性能并不高，为了尽量少的读磁盘，必须让查询过程访问尽量少的数据块，使用N叉树，让兄弟节点放在一个数据块，就可以使查询过程访问的数据块变少。

     **N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。**

### InnoDB 的索引模型

InnoDB实用B+树作为索引模型，每一个索引在InnoDB中对应一颗B+树。主键也是一种特殊的索引，因此主键会有一颗B+树，主键的B+树也是比较特殊的，它的叶子节点中存储着整行数据，而其他的索引B+树的叶子节点中只存储主键。所以，当实用主键作为条件进行查询的时候，只需要查询组件的索引树就可以查询到所有数据，如果实用其他的索引字段，则会先通过对应的索引查询到主键，然后通过主键查询到其他数据，相比组件作为条件进行查询来说，多了一个查询步骤，在应用中应尽量实用主键进行查询。

B+树为了维护索引的有序性，需要在插入新值的时候做必要的维护。若是数据页慢了，需要将一个页的数据分拆到两个页，这势必会对插入效率产生影响，分裂后的查询效率也会收到影响。如果两个页的数据较少就会将两个页合并成一个数据页。

基于以上插入时对索引的维护，当使用主键自增时对数据库进行插入操作，那么就会很少遇到要分页的情况，不需要挪动其他的记录。从性能与存储空间方面来考量，自增主键是较为合适的。

如果表中只有一个唯一索引的情况下，使用业务主键也是可以的。

### 覆盖索引

覆盖索引是指，在索引中已经存在了需要的字段，就不需要通过主键值去主键索引树搜索这个字段了。

### 最左前缀原则

当sql中出现在where条件中的字段能够匹配到某个索引的最左前缀集合中的一个，那么这条sql就会使用这条索引。

使用`Like`语句时，在`%`通配符只在条件结尾处出现的时候也可以使用索引，如果在对应字段有索引的话

`最左前缀集合`就是从一个列表的最左边的元素起，数N个元素作为一个前缀加入集合中，然后再从头开始数N+1个元素作为一个前缀加入集合，直到N等于此列表的元素个数，N从1开始。

### 索引下推

索引下推在Mysql5.6以后出现，就是在通过有索引的字段在索引树上进行搜索时，其他不符合最左前缀的字段如果在索引中存在，那么就不用使用主键回表获取字段值去检查是否匹配，直接取索引中的值进行比对即可。

## Mysql全局锁

Mysql有两种让整个数据库只读的方法：

1. 命令 `flush table with read loc`（FTWRL）

   执行此命令的连接断开后，会自动回复

2. set global readonly=true

   执行此命令后，只有再次执行`set global readonly=false`，才能使得库不再只读，无论执行此命令的客户端状态如何。

一般全局逻辑备份的时候需要让整个库只读，推荐使用第一种方法，如果所有的表都是`InnoDB`引擎的，则可以在`可重复读`的事务隔离下开启一个事务，然后进行备份，这种方法最好，可以不影响其他线程对数据库的读写，也不会导致数据不一致。